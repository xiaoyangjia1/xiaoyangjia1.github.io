<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>Hello啊 Worker</title><meta name="description" content="Tate Yang的个人博客网站"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/yqx.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
我们总说JS是单线程的，根据上一文我们也了解了JS引擎线程.
单线程意味着不能把工作委托给独立的线程或进程去做。JS的单线程可以保证它与不同的浏览器API兼容。如果JS可以多线程执行并发更改，那么像DOM这样的API就会出现问题。
这正是我们本文讨论的工作者线程的价值所在：允许把主线程的工作转嫁给独立的实体，而不会改变现有的单线程模型。
工作者线程简介JS环境实际上托管在操作系统中的虚拟环境。使用工作者线程，浏览器可以在原始界面环境之外再分配一个完全独立的二级子环境。
这个子环境不能与依赖单线程交互的API（如DOM）互操作，但可以与父环境并行执行代码
工作者线程与线程
工作者线程是以实际线程实现的
工作者线程并行执行但不一定再同一个进程里
工作者线程可以共享某些内存，但不共享全部内存
创建工作者线程的开.."><meta name="generator" content="Hexo 5.4.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Tate Yang's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Hello啊 Worker</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="toc-text">工作者线程简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text">工作者线程与线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B%E7%B1%BB%E5%9E%8B"><span class="toc-text">工作者线程类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%93%E7%94%A8%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B"><span class="toc-text">专用工作者线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B"><span class="toc-text">共享工作者线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B"><span class="toc-text">服务工作者线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WorkerGlobalScope"><span class="toc-text">WorkerGlobalScope</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WorkerGlobalScope%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-text">WorkerGlobalScope属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WorkerGlobalScope%E7%9A%84%E5%AD%90%E7%B1%BB"><span class="toc-text">WorkerGlobalScope的子类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%93%E7%94%A8%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B-1"><span class="toc-text">专用工作者线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B"><span class="toc-text">创建工作者线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E9%99%90%E5%88%B6"><span class="toc-text">安全限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Worker%E5%AF%B9%E8%B1%A1"><span class="toc-text">使用Worker对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DedicatedWorkerGlobalScope"><span class="toc-text">DedicatedWorkerGlobalScope</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8FMessagePorts"><span class="toc-text">隐式MessagePorts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BB%88%E6%AD%A2"><span class="toc-text">内部终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E7%BB%88%E6%AD%A2"><span class="toc-text">外部终止</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEWorker%E9%80%89%E9%A1%B9"><span class="toc-text">配置Worker选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8JS%E8%A1%8C%E5%86%85%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B"><span class="toc-text">在JS行内创建工作者线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">序列化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%8A%A8%E6%80%81%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC"><span class="toc-text">在工作者线程中动态执行脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E4%BB%BB%E5%8A%A1%E5%88%B0%E5%AD%90%E7%BA%BF%E7%A8%8B"><span class="toc-text">委托任务到子线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B%E9%94%99%E8%AF%AF"><span class="toc-text">处理工作者线程错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E4%B8%93%E7%94%A8%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">与专用工作者线程之间的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#postMessage"><span class="toc-text">postMessage()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MessageChannel"><span class="toc-text">MessageChannel()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BroadcastChannel"><span class="toc-text">BroadcastChannel()</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B"><i class="tag post-item-tag">工作者线程</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Hello啊 Worker</h1><time class="has-text-grey" datetime="2021-12-27T11:47:15.000Z">2021-12-27</time><article class="mt-2 post-content"><p><img src="https://s2.loli.net/2021/12/27/OXe4v3YT1fxFsR9.jpg" alt="微信图片_20211227195211.jpg"></p>
<p>我们总说JS是单线程的，根据上一文我们也了解了JS引擎线程.</p>
<p>单线程意味着不能把工作委托给独立的线程或进程去做。JS的单线程可以保证它与不同的浏览器API兼容。如果JS可以多线程执行并发更改，那么像DOM这样的API就会出现问题。</p>
<p>这正是我们本文讨论的工作者线程的价值所在：允许把主线程的工作转嫁给独立的实体，而不会改变现有的单线程模型。</p>
<h2 id="工作者线程简介"><a href="#工作者线程简介" class="headerlink" title="工作者线程简介"></a>工作者线程简介</h2><p>JS环境实际上托管在操作系统中的虚拟环境。使用工作者线程，浏览器可以在原始界面环境之外再分配一个完全独立的二级子环境。</p>
<p>这个子环境不能与依赖单线程交互的API（如DOM）互操作，但可以与父环境并行执行代码</p>
<h3 id="工作者线程与线程"><a href="#工作者线程与线程" class="headerlink" title="工作者线程与线程"></a>工作者线程与线程</h3><ul>
<li>工作者线程是以实际线程实现的</li>
<li>工作者线程并行执行但不一定再同一个进程里</li>
<li>工作者线程可以共享某些内存，但不共享全部内存</li>
<li>创建工作者线程的开销更大</li>
</ul>
<h3 id="工作者线程类型"><a href="#工作者线程类型" class="headerlink" title="工作者线程类型"></a>工作者线程类型</h3><p>web工作者线程规范中定义了三种主要的工作者线程：专用工作者线程、共享工作者线程、服务工作者线程</p>
<h4 id="专用工作者线程"><a href="#专用工作者线程" class="headerlink" title="专用工作者线程"></a>专用工作者线程</h4><p>通常简称为工作者线程、Web Worker或Worker.只能被创建它的页面使用</p>
<h4 id="共享工作者线程"><a href="#共享工作者线程" class="headerlink" title="共享工作者线程"></a>共享工作者线程</h4><p>共享工作者线程可以被多个不同的上下文使用，包括不同的页面。任何与创建共享工作者线程的脚本同源的脚本，都可以向共享工作者线程发送给消息或从中接受消息</p>
<h4 id="服务工作者线程"><a href="#服务工作者线程" class="headerlink" title="服务工作者线程"></a>服务工作者线程</h4><p>主要用途是拦截、重定向和修改页面发出的请求，充当网络请求仲裁者的角色。</p>
<h3 id="WorkerGlobalScope"><a href="#WorkerGlobalScope" class="headerlink" title="WorkerGlobalScope"></a>WorkerGlobalScope</h3><p>在网页中，window对象可以向运行在其中的脚本暴露各种全局属性。在工作者线程内部，没有window的概念。这里的全局对象是WorkerGlobalScope的实例，通过self关键字暴露出来。</p>
<h4 id="WorkerGlobalScope属性和方法"><a href="#WorkerGlobalScope属性和方法" class="headerlink" title="WorkerGlobalScope属性和方法"></a>WorkerGlobalScope属性和方法</h4><p>self上可用的属性和方法是window对象上属性的严格子集。其中有些属性或方法会返回特定于工作者线程的版本。</p>
<h4 id="WorkerGlobalScope的子类"><a href="#WorkerGlobalScope的子类" class="headerlink" title="WorkerGlobalScope的子类"></a>WorkerGlobalScope的子类</h4><p>每种类型的工作者线程都使用了自己特定的全局对象，继承关系如下</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget">EventTarget</a>-&gt;<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WorkerGlobalScope">WorkerGlobalScope</a>-&gt;子类</p>
<ul>
<li>专用工作者线程使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/DedicatedWorkerGlobalScope">DedicatedWorkerGlobalScope</a></li>
<li>共享工作者线程使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorkerGlobalScope">SharedWorkerGlobalScope</a></li>
<li>服务工作者线程使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerGlobalScope">ServiceWorkerGlobalScope</a></li>
</ul>
<p><code>self</code> 属性返回每个内容的专门 scope .</p>
<h2 id="专用工作者线程-1"><a href="#专用工作者线程-1" class="headerlink" title="专用工作者线程"></a>专用工作者线程</h2><p>这样的线程可以与父页面进行交换信息、发送网络请求、执行文件输入/输出、进行密集计算、处理大量数据，以及实现是其他不适合在页面执行线程的任务（防止阻塞页面的渲染）</p>
<p>使用工作者线程时，脚本在哪里执行，在哪里加载是非常重要的概念。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>可以称专用者线程为后台脚本。JS线程的各个方面，包括生命周期管理、代码路径和输入输出，都由初始化线程时提供的脚本来控制。</p>
<h4 id="创建工作者线程"><a href="#创建工作者线程" class="headerlink" title="创建工作者线程"></a>创建工作者线程</h4><p>最常见的方式是加载JS文件。将文件路径提供给Worker构造函数，然后构造函数再在后台异步加载并实例化工作者线程。</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> myWorker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>aURL<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>假设在main.js文件中创建工作者线程，加载worker.js文件</p>
<p>worker文件是在后台加载的，工作者线程的初始化完全独立于main.js</p>
<p>工作者线程本身存在于独立的JavaScript环境中，因此main.js必须以Worker对象为代理实现与工作者线程通信。</p>
<h4 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h4><p>工作者线程的脚本必须遵守同源策略</p>
<h4 id="使用Worker对象"><a href="#使用Worker对象" class="headerlink" title="使用Worker对象"></a>使用Worker对象</h4><p>Worker对象是与刚创建的专用工作者线程通信的连接点。它可用于在工作者线程和父上下文间传递信息，以及捕获专用工作者线程发出的事件。</p>
<p>在终止工作者线程之前，Worker对象不会被垃圾回收，也不能通过编程的方式恢复对之前Worker对象的引用。</p>
<h4 id="DedicatedWorkerGlobalScope"><a href="#DedicatedWorkerGlobalScope" class="headerlink" title="DedicatedWorkerGlobalScope"></a>DedicatedWorkerGlobalScope</h4><p>在专用工作者内部，全局作用域是DedicatedWorkerGlobalScope的实例，工作者线程通过self关键字访问该全局作用域。</p>
<p>因为工作者线程具有不可忽略的启动延迟，所以即使Worker对象存在，工作者线程的日志也会在主线程的日志之后打印出来</p>
<h3 id="隐式MessagePorts"><a href="#隐式MessagePorts" class="headerlink" title="隐式MessagePorts"></a>隐式MessagePorts</h3><p>专用工作者线程隐式使用了Message在两个上下文之间通信</p>
<p>在工作者线程内部调用close()(或在外部调用terminate())不仅会关闭MessagePort,也会终止线程</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>专用工作者线程可以区分为下列三个状态：初始化、活动和终止。</p>
<p>无法通过Worker对象确定工作者线程当前是处理初始化、活动还是终止状态。</p>
<h4 id="内部终止"><a href="#内部终止" class="headerlink" title="内部终止"></a>内部终止</h4><p>调用close()后，工作者线程的执行并没有立即停止，close()会通知工作者线程取消事件循环中的所有任务，并阻止立即添加新任务。</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> workerScript <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
self.postMessage('foo')
self.close()
self.postMessage('bar')
setTimeOut(()=>self.postMessage('baz'),0)
</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">const</span> workerScriptBlob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span><span class="token punctuation">[</span>workerScript<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> workerScriptBlobUrl <span class="token operator">=</span> <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>workerScriptBlob<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>workerScriptBlobUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>
worker<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">&#123;</span>data<span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token operator">=></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>worker<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Worker</span>
<span class="token comment">// foo</span>
<span class="token comment">// bar</span></code></pre>

<p>因为延迟的问题所以先打印Worker对象，</p>
<p>注意：在这里工作者线程不执行同步停止，所以bar也被打印出来</p>
<p>因为有些浏览器不支持本地通过文件路径形式创建工作者线程，所以本文均采用行内创建的方式做例</p>
<h4 id="外部终止"><a href="#外部终止" class="headerlink" title="外部终止"></a>外部终止</h4><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> workerScript <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
self.onmessage=(&#123;data&#125;) =>console.log(data)
</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">const</span> workerScriptBlob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span><span class="token punctuation">[</span>workerScript<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> workerScriptBlobUrl <span class="token operator">=</span> <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>workerScriptBlob<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>workerScriptBlobUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>
    worker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
    worker<span class="token punctuation">.</span><span class="token function">terminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    worker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span>worker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'baz'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
worker<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">&#123;</span>data<span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token operator">=></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>worker<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Worker对象</span>
<span class="token comment">// foo</span></code></pre>

<p>一旦调用terminate(),工作者线程的消息队列就会被清理并锁住，这也是只打印foo的原因</p>
<p>close()和terminate()这两个方法是幂等操作，仅仅是将Worker标记为teardown,因此多次调用不会有不好的影响。</p>
<p>在整个生命周期中，一个专用工作者线程只会关联一个网页（文档）。除非明确终止，否则只要关联文档存在，专用者线程就会存在。</p>
<p>如果浏览器离开网页（通过导航关闭标签页，或关闭窗口），它会将与其关联的工作者线程标记为终止，它们的执行也会停止。</p>
<h3 id="配置Worker选项"><a href="#配置Worker选项" class="headerlink" title="配置Worker选项"></a>配置Worker选项</h3><ul>
<li>name：在工作者线程中通过self.name获取字符串标识符</li>
<li>type: 表示加载脚本的运行方式</li>
<li>credentials：当type为module时，指定如何获取与传输凭证数据相关的工作者线程模块脚本。</li>
</ul>
<h3 id="在JS行内创建工作者线程"><a href="#在JS行内创建工作者线程" class="headerlink" title="在JS行内创建工作者线程"></a>在JS行内创建工作者线程</h3><p>专用工作者线程也可以通过Blob对象URL在行内脚本创建，这样可以更快的初始化工作者线程，因为没有网络延迟。</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>
  <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>
    <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">self.addEventListener('message',(&#123;data&#125;)=>console.log(data))</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
worker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">"nihao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>工作者线程可以利用函数序列化来初始化行内脚本，因为函数的toString()方法返回函数代码的字符串，而函数可以在父上下文中定义但在子上下文中执行</p>
<h5 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h5><p>序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> n <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> n <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">const</span> workerScript <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">self.postMessage((</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>fibonacci<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">)(4))</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span><span class="token punctuation">[</span>workerScript<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
worker<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">&#123;</span> data <span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>虽然递归计算斐波那契数列比较耗时，但所有的计算都会委托到工作者线程，因此并不会影响父上下文的性能</p>
<blockquote>
<p>不过像这样序列化函数有个前提，就是函数体内不能使用通过闭包获得的引用，也包括全局变量，比如window，因为这些引用在工作者线程中执行会报错</p>
</blockquote>
<h3 id="在工作者线程中动态执行脚本"><a href="#在工作者线程中动态执行脚本" class="headerlink" title="在工作者线程中动态执行脚本"></a>在工作者线程中动态执行脚本</h3><p>在工作者线程中可以使用importScripts()方法通过编程方式加载和执行任意脚本。</p>
<p>该方法可用于全局Worker对象，可接受任意数量的脚本作为参数，浏览器下宅他们没有限制，但执行会严格按照他们在参数列表的顺序进行。</p>
<p>所有导入的脚本也会共享作用域</p>
<h3 id="委托任务到子线程"><a href="#委托任务到子线程" class="headerlink" title="委托任务到子线程"></a>委托任务到子线程</h3><p>工作者线程中可以再创建子工作者线程，顶级工作者线程的脚本和子工作者线程的脚本都必须从与主页相同的源加载。</p>
<h3 id="处理工作者线程错误"><a href="#处理工作者线程错误" class="headerlink" title="处理工作者线程错误"></a>处理工作者线程错误</h3><p>如果工作者线程脚本抛出了错误，该工作者线程沙盒可以阻止它打断父线程的执行。</p>
<p>不过相应的错误事件仍会冒泡到工作者线程上下文，因此可以通过在Worker对象上设置错误事件侦听器访问到。</p>
<h3 id="与专用工作者线程之间的通信"><a href="#与专用工作者线程之间的通信" class="headerlink" title="与专用工作者线程之间的通信"></a>与专用工作者线程之间的通信</h3><h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage()"></a>postMessage()</h4><h4 id="MessageChannel"><a href="#MessageChannel" class="headerlink" title="MessageChannel()"></a>MessageChannel()</h4><ul>
<li>端口</li>
</ul>
<h4 id="BroadcastChannel"><a href="#BroadcastChannel" class="headerlink" title="BroadcastChannel()"></a>BroadcastChannel()</h4><p>同源脚本能够通过BroadcastChannel相互之间发送和接受消息，这种信道没有端口所有权的概念，如果没有实时监听这个信道，广播的消息就不会有人处理。</p>
<p>太多了，后续再补上</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2021/12/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%9A%E8%81%8A%E8%81%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/" title="浏览器那些事：聊聊浏览器内核的多线程机制"><span class="has-text-weight-semibold">Next: 浏览器那些事：聊聊浏览器内核的多线程机制</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xiaoyangjia1/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/xiaoyangjia1"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Tate Yang 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>