<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>响应式计算与侦听</title><meta name="description" content="Tate Yang的个人博客网站"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/yqx.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
监听变量的变化做出响应的反应我们通常会用到computed和watch和watchEffect这几种方式。
但三者是怎么使用的以及差异在哪，我们今天就来探个究竟
computed类型声明export type ComputedGetter&amp;lt;T&gt; = (...args: any[]) =&gt; T
export interface ComputedRef&amp;lt;T = any&gt; extends WritableComputedRef&amp;lt;T&gt; &amp;#123;
  readonly value: T
  [ComputedRefSymbol]: true
&amp;#125;
// 只读的
export function computed&amp;lt;T&gt;(
  getter: ComputedGetter&amp;lt;T&gt;,.."><meta name="generator" content="Hexo 5.4.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Yangqixiang's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">响应式计算与侦听</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#computed"><span class="toc-text">computed</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-text">类型声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95computed"><span class="toc-text">调试computed</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#watchEffect"><span class="toc-text">watchEffect</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E-1"><span class="toc-text">类型声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E7%9B%91%E5%90%AC"><span class="toc-text">停止监听</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-text">清除副作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%AF%E4%BD%9C%E7%94%A8%E5%88%B7%E6%96%B0%E6%97%B6%E6%9C%BA"><span class="toc-text">副作用刷新时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%E8%B0%83%E8%AF%95"><span class="toc-text">监听器调试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#watch"><span class="toc-text">watch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-text">类型定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-2"><span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%A6%E5%90%AC%E5%8D%95%E4%B8%80%E6%BA%90"><span class="toc-text">侦听单一源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%A6%E5%90%AC%E5%A4%9A%E4%B8%AA%E6%BA%90"><span class="toc-text">侦听多个源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%A6%E5%90%AC%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1"><span class="toc-text">侦听响应式对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8EwatchEffect%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与watchEffect的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E-watchEffect-%E5%85%B1%E4%BA%AB%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-text">与 watchEffect 共享的行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8Ecomputed%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">与computed的区别</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/vue3"><i class="tag post-item-tag">vue3</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">响应式计算与侦听</h1><time class="has-text-grey" datetime="2021-12-19T08:39:05.000Z">2021-12-19</time><article class="mt-2 post-content"><p><img src="https://s2.loli.net/2021/12/19/m4YqWOPs21X5MrK.jpg" alt="微信图片_20211219164119.jpg"></p>
<p>监听变量的变化做出响应的反应我们通常会用到computed和watch和watchEffect这几种方式。</p>
<p>但三者是怎么使用的以及差异在哪，我们今天就来探个究竟</p>
<h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> type ComputedGetter<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args<span class="token operator">:</span> any<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">T</span>
<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">ComputedRef</span><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token operator">=</span> any<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">WritableComputedRef</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>
  readonly value<span class="token operator">:</span> <span class="token constant">T</span>
  <span class="token punctuation">[</span>ComputedRefSymbol<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 只读的</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> computed<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">(</span>
  getter<span class="token operator">:</span> ComputedGetter<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">,</span>
  debugOptions<span class="token operator">?</span><span class="token operator">:</span> DebuggerOptions
<span class="token punctuation">)</span><span class="token operator">:</span> ComputedRef<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></code></pre>

<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">WritableComputedOptions</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>
  get<span class="token operator">:</span> ComputedGetter<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span>
  set<span class="token operator">:</span> ComputedSetter<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">WritableComputedRef</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Ref</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>
  readonly effect<span class="token operator">:</span> ReactiveEffect<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 可写的</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> computed<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">(</span>
  options<span class="token operator">:</span> WritableComputedOptions<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">,</span>
  debugOptions<span class="token operator">?</span><span class="token operator">:</span> DebuggerOptions
<span class="token punctuation">)</span><span class="token operator">:</span> WritableComputedRef<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></code></pre>

<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">DebuggerOptions</span> <span class="token punctuation">&#123;</span>
  onTrack<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">event<span class="token operator">:</span> DebuggerEvent</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span>
  onTrigger<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">event<span class="token operator">:</span> DebuggerEvent</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">export</span> type DebuggerEvent <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  effect<span class="token operator">:</span> ReactiveEffect
<span class="token punctuation">&#125;</span> <span class="token operator">&amp;</span> DebuggerEventExtraInfo

<span class="token keyword">export</span> type DebuggerEventExtraInfo <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  target<span class="token operator">:</span> object
  type<span class="token operator">:</span> TrackOpTypes <span class="token operator">|</span> TriggerOpTypes
  key<span class="token operator">:</span> any
  newValue<span class="token operator">?</span><span class="token operator">:</span> any
  oldValue<span class="token operator">?</span><span class="token operator">:</span> any
  oldTarget<span class="token operator">?</span><span class="token operator">:</span> Map<span class="token operator">&lt;</span>any<span class="token punctuation">,</span> any<span class="token operator">></span> <span class="token operator">|</span> Set<span class="token operator">&lt;</span>any<span class="token operator">></span>
<span class="token punctuation">&#125;</span></code></pre>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>根据类型定义我们知道computed可以接受一个 getter 函数，并根据 getter 的返回值返回一个不可变的响应式 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/refs-api.html#ref">ref</a> 对象。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script setup lang<span class="token operator">=</span><span class="token string">"ts"</span><span class="token operator">></span>
<span class="token keyword">import</span> <span class="token punctuation">&#123;</span> ref<span class="token punctuation">,</span> computed <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> plusOne <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> count<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>plusOne<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// plusOne.value++; // Cannot assign to 'value' because it is a read-only property.</span>
<span class="token keyword">function</span> <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  count<span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>

<span class="token operator">&lt;</span>template<span class="token operator">></span>
  <span class="token operator">&lt;</span>div<span class="token operator">></span>
    <span class="token operator">&lt;</span>p<span class="token operator">></span>count<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> count <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> plusOne<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> plusOne <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>
    <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"addCount"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span></code></pre>

<p>或者，接受一个具有 <code>get</code> 和 <code>set</code> 函数的对象，用来创建可写的 ref 对象。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> plusOne <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> count<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token parameter">val</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    count<span class="token punctuation">.</span>value <span class="token operator">=</span> val <span class="token operator">-</span> <span class="token number">1</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

plusOne<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 0</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>plusOne<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span></code></pre>

<h3 id="调试computed"><a href="#调试computed" class="headerlink" title="调试computed"></a>调试computed</h3><p><code>computed</code> 可接受一个带有 <code>onTrack</code> 和 <code>onTrigger</code> 选项的对象作为第二个参数：</p>
<ul>
<li><code>onTrack</code> 会在某个响应式 property 或 ref 作为依赖被追踪时调用。</li>
<li><code>onTrigger</code> 会在侦听回调被某个依赖的修改触发时调用。</li>
</ul>
<p>所有回调都会收到一个 debugger 事件，其中包含了一些依赖相关的信息。推荐在这些回调内放置一个 <code>debugger</code> 语句以调试依赖。</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> plusOne <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> count<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>
  <span class="token function">onTrack</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 当 count.value 作为依赖被追踪时触发</span>
    <span class="token keyword">debugger</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token function">onTrigger</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 当 count.value 被修改时触发</span>
    <span class="token keyword">debugger</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token comment">// 访问 plusOne，应该触发 onTrack</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>plusOne<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
<span class="token comment">// 修改 count.value，应该触发 onTrigger</span>
count<span class="token punctuation">.</span>value<span class="token operator">++</span></code></pre>

<p><code>onTrack</code> 和 <code>onTrigger</code> 仅在开发模式下生效。</p>
<h2 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h2><h3 id="类型声明-1"><a href="#类型声明-1" class="headerlink" title="类型声明"></a>类型声明</h3><pre class="language-javascript" data-language="javascript"><code class="language-javascript">declare type <span class="token function-variable function">InvalidateCbRegistrator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function-variable function">cb</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> declare type <span class="token function-variable function">WatchEffect</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">onInvalidate<span class="token operator">:</span> InvalidateCbRegistrator</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> declare <span class="token keyword">function</span> <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token parameter">effect<span class="token operator">:</span> WatchEffect<span class="token punctuation">,</span> options<span class="token operator">?</span><span class="token operator">:</span> WatchOptionsBase</span><span class="token punctuation">)</span><span class="token operator">:</span> WatchStopHandle<span class="token punctuation">;</span>

<span class="token keyword">export</span> declare <span class="token keyword">interface</span> <span class="token class-name">WatchOptionsBase</span> <span class="token keyword">extends</span> <span class="token class-name">DebuggerOptions</span> <span class="token punctuation">&#123;</span>
    flush<span class="token operator">?</span><span class="token operator">:</span> <span class="token string">'pre'</span> <span class="token operator">|</span> <span class="token string">'post'</span> <span class="token operator">|</span> <span class="token string">'sync'</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
    
<span class="token keyword">export</span> declare type <span class="token function-variable function">WatchStopHandle</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span></code></pre>

<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 0</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  count<span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token comment">// -> logs 1</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<h3 id="停止监听"><a href="#停止监听" class="headerlink" title="停止监听"></a>停止监听</h3><p>当 <code>watchEffect</code> 在组件的 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-setup.html">setup()</a> 函数或<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-lifecycle-hooks.html">生命周期钩子</a>被调用时，侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止。</p>
<p>在一些情况下，也可以显式调用返回值以停止侦听：</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> stop <span class="token operator">=</span> <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token comment">// later</span>
<span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>

<h3 id="清除副作用"><a href="#清除副作用" class="headerlink" title="清除副作用"></a>清除副作用</h3><p>有时副作用函数会执行一些异步的副作用，这些响应需要在其失效时清除 (即完成之前状态已改变了) 。所以侦听副作用传入的函数可以接收一个 <code>onInvalidate</code> 函数作入参，用来注册清理失效时的回调。当以下情况发生时，这个失效回调会被触发：</p>
<ul>
<li>副作用即将重新执行时</li>
<li>侦听器被停止 (如果在 <code>setup()</code> 或生命周期钩子函数中使用了 <code>watchEffect</code>，则在组件卸载时)</li>
</ul>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token parameter">onInvalidate</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> token <span class="token operator">=</span> <span class="token function">performAsyncOperation</span><span class="token punctuation">(</span>id<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
  <span class="token function">onInvalidate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// id has changed or watcher is stopped.</span>
    <span class="token comment">// invalidate previously pending async operation</span>
    token<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre>

<p>我们之所以是通过传入一个函数去注册失效回调，而不是从回调返回它，是因为返回值对于异步错误处理很重要。</p>
<p>在执行数据请求时，副作用函数往往是一个异步函数：</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token parameter">onInvalidate</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token function">onInvalidate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token comment">// 我们在Promise解析之前注册清除函数</span>
  data<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchData</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre>

<p>我们知道异步函数都会隐式地返回一个 Promise，但是清理函数必须要在 Promise 被 resolve 之前被注册。另外，Vue 依赖这个返回的 Promise 来自动处理 Promise 链上的潜在错误。</p>
<h3 id="副作用刷新时机"><a href="#副作用刷新时机" class="headerlink" title="副作用刷新时机"></a>副作用刷新时机</h3><p>Vue 的响应性系统会缓存副作用函数，并异步地刷新它们，这样可以避免同一个“tick” 中多个状态改变导致的不必要的重复调用。在核心的具体实现中，组件的 <code>update</code> 函数也是一个被侦听的副作用。当一个用户定义的副作用函数进入队列时，默认情况下，会在所有的组件 <code>update</code> <strong>前</strong>执行：</p>
<pre class="language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;
  &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;div&gt;
&lt;&#x2F;template&gt;

&lt;script&gt;
export default &#123;
  setup() &#123;
    const count &#x3D; ref(0)

    watchEffect(() &#x3D;&gt; &#123;
      console.log(count.value)
    &#125;)

    return &#123;
      count
    &#125;
  &#125;
&#125;
&lt;&#x2F;script&gt;</code></pre>

<p>在这个例子中：</p>
<ul>
<li><code>count</code> 会在初始运行时同步打印出来</li>
<li>更改 <code>count</code> 时，将在组件<strong>更新前</strong>执行副作用。</li>
</ul>
<p>如果需要在组件更新(例如：当与<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-template-refs.html#%E4%BE%A6%E5%90%AC%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8">模板引用</a>一起)<strong>后</strong>重新运行侦听器副作用，我们可以传递带有 <code>flush</code> 选项的附加 <code>options</code> 对象 (默认为 <code>&#39;pre&#39;</code>)：</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 在组件更新后触发，这样你就可以访问更新的 DOM。</span>
<span class="token comment">// 注意：这也将推迟副作用的初始运行，直到组件的首次渲染完成。</span>
<span class="token function">watchEffect</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#123;</span>
    flush<span class="token operator">:</span> <span class="token string">'post'</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">)</span></code></pre>

<p><code>flush</code> 选项还接受 <code>sync</code>，这将强制效果始终同步触发。然而，这是低效的，应该很少需要。</p>
<p>从 Vue 3.2.0 开始，<code>watchPostEffect</code> 和 <code>watchSyncEffect</code> 别名也可以用来让代码意图更加明显。</p>
<h3 id="监听器调试"><a href="#监听器调试" class="headerlink" title="监听器调试"></a>监听器调试</h3><p>与computed差不多</p>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><pre class="language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; 监听单一源
export declare function watch&lt;T, Immediate extends Readonly&lt;boolean&gt; &#x3D; false&gt;(source: WatchSource&lt;T&gt;, cb: WatchCallback&lt;T, Immediate extends true ? T | undefined : T&gt;, options?: WatchOptions&lt;Immediate&gt;): WatchStopHandle;

export declare type WatchSource&lt;T &#x3D; any&gt; &#x3D; Ref&lt;T&gt; | ComputedRef&lt;T&gt; | (() &#x3D;&gt; T);

export declare type WatchCallback&lt;V &#x3D; any, OV &#x3D; any&gt; &#x3D; (value: V, oldValue: OV, onInvalidate: InvalidateCbRegistrator) &#x3D;&gt; any;

declare type InvalidateCbRegistrator &#x3D; (cb: () &#x3D;&gt; void) &#x3D;&gt; void;

export declare interface WatchOptions&lt;Immediate &#x3D; boolean&gt; extends WatchOptionsBase &#123;
    immediate?: Immediate;
    deep?: boolean;
&#125;</code></pre>

<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 监听多个源</span>
<span class="token keyword">export</span> declare <span class="token keyword">function</span> watch<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">MultiWatchSources</span><span class="token punctuation">,</span> Immediate <span class="token keyword">extends</span> <span class="token class-name">Readonly</span><span class="token operator">&lt;</span>boolean<span class="token operator">></span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token operator">></span><span class="token punctuation">(</span>sources<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cb<span class="token operator">:</span> WatchCallback<span class="token operator">&lt;</span>MapSources<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token operator">></span><span class="token punctuation">,</span> MapSources<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> Immediate<span class="token operator">>></span><span class="token punctuation">,</span> options<span class="token operator">?</span><span class="token operator">:</span> WatchOptions<span class="token operator">&lt;</span>Immediate<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> WatchStopHandle<span class="token punctuation">;</span></code></pre>

<h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><h4 id="侦听单一源"><a href="#侦听单一源" class="headerlink" title="侦听单一源"></a>侦听单一源</h4><p>侦听器数据源可以是一个具有返回值的 getter 函数，也可以直接是一个 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/refs-api.html#ref">ref</a>或computedRef</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 侦听一个 getter</span>
<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> count<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token function">watch</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> state<span class="token punctuation">.</span>count<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">count<span class="token punctuation">,</span> prevCount</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">)</span>

<span class="token comment">// 直接侦听一个 ref</span>
<span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">watch</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">count<span class="token punctuation">,</span> prevCount</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token comment">// 监听computedRef</span>
<span class="token keyword">const</span> plusOne <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> count<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">watch</span><span class="token punctuation">(</span>plusOne<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">plusOne<span class="token punctuation">,</span> prevplusOne</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>plusOne<span class="token punctuation">,</span> prevplusOne<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre>

<h4 id="侦听多个源"><a href="#侦听多个源" class="headerlink" title="侦听多个源"></a>侦听多个源</h4><p>侦听器还可以使用数组以同时侦听多个源：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">[</span>fooRef<span class="token punctuation">,</span> barRef<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>foo<span class="token punctuation">,</span> bar<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>prevFoo<span class="token punctuation">,</span> prevBar<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre>

<p>如果你在同一个函数里同时改变这些被侦听的来源，侦听器仍只会执行一次：</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> firstName <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> lastName <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>

  <span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">[</span>firstName<span class="token punctuation">,</span> lastName<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">newValues<span class="token punctuation">,</span> prevValues</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newValues<span class="token punctuation">,</span> prevValues<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

  <span class="token keyword">const</span> <span class="token function-variable function">changeValues</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    firstName<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">'John'</span>
    lastName<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">'Smith'</span>
    <span class="token comment">// 打印 ["John", "Smith"] ["", ""]</span>
  <span class="token punctuation">&#125;</span>

  <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> changeValues <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>注意多个同步更改只会触发一次侦听器。</p>
<p>通过更改设置 <code>flush: &#39;sync&#39;</code>，我们可以为每个更改都强制触发侦听器，尽管这通常是不推荐的。或者，可以用 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/global-api.html#nexttick">nextTick</a> 等待侦听器在下一步改变之前运行。例如：</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">changeValues</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  firstName<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">'John'</span> <span class="token comment">// 打印 ["John", ""] ["", ""]</span>
  <span class="token keyword">await</span> <span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  lastName<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">'Smith'</span> <span class="token comment">// 打印 ["John", "Smith"] ["John", ""]</span>
<span class="token punctuation">&#125;</span></code></pre>

<h4 id="侦听响应式对象"><a href="#侦听响应式对象" class="headerlink" title="侦听响应式对象"></a>侦听响应式对象</h4><p>使用侦听器来比较一个数组或对象的值，这些值是响应式的，要求它有一个由值构成的副本。</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> numbers <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token function">watch</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">[</span><span class="token operator">...</span>numbers<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">numbers<span class="token punctuation">,</span> prevNumbers</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> prevNumbers<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">)</span>

numbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">// logs: [1,2,3,4,5] [1,2,3,4]</span></code></pre>

<p>尝试检查深度嵌套对象或数组中的 property 变化时，仍然需要 <code>deep</code> 选项设置为 true。</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> 
  id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  attributes<span class="token operator">:</span> <span class="token punctuation">&#123;</span> 
    name<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token function">watch</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> state<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'not deep'</span><span class="token punctuation">,</span> state<span class="token punctuation">.</span>attributes<span class="token punctuation">.</span>name<span class="token punctuation">,</span> prevState<span class="token punctuation">.</span>attributes<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">)</span>

<span class="token function">watch</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> state<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'deep'</span><span class="token punctuation">,</span> state<span class="token punctuation">.</span>attributes<span class="token punctuation">.</span>name<span class="token punctuation">,</span> prevState<span class="token punctuation">.</span>attributes<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#123;</span> deep<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">)</span>

state<span class="token punctuation">.</span>attributes<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Alex'</span> <span class="token comment">// 日志: "deep" "Alex" "Alex"</span></code></pre>

<p>然而，侦听一个响应式对象或数组将始终返回该对象的当前值和上一个状态值的引用。为了完全侦听深度嵌套的对象和数组，可能需要对值进行深拷贝。这可以通过诸如 <a target="_blank" rel="noopener" href="https://lodash.com/docs/4.17.15#cloneDeep">lodash.cloneDeep</a> 这样的实用工具来实现。</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> _ <span class="token keyword">from</span> <span class="token string">'lodash'</span>

<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  attributes<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token function">watch</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> _<span class="token punctuation">.</span><span class="token function">cloneDeep</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>attributes<span class="token punctuation">.</span>name<span class="token punctuation">,</span> prevState<span class="token punctuation">.</span>attributes<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">)</span>

state<span class="token punctuation">.</span>attributes<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Alex'</span> <span class="token comment">// 日志: "Alex" ""</span></code></pre>



<h3 id="与watchEffect的区别"><a href="#与watchEffect的区别" class="headerlink" title="与watchEffect的区别"></a>与watchEffect的区别</h3><p>与 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html#watcheffect">watchEffect</a> 比较，<code>watch</code> 允许我们：</p>
<ul>
<li>懒执行副作用；</li>
<li>更具体地说明什么状态应该触发侦听器重新运行；</li>
<li>访问侦听状态变化前后的值。</li>
</ul>
<h3 id="与-watchEffect-共享的行为"><a href="#与-watchEffect-共享的行为" class="headerlink" title="与 watchEffect 共享的行为"></a>与 <code>watchEffect</code> 共享的行为</h3><p><code>watch</code> 与 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html#watcheffect"><code>watchEffect</code></a>共享<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html#%E5%81%9C%E6%AD%A2%E4%BE%A6%E5%90%AC">停止侦听</a>，<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html#%E6%B8%85%E9%99%A4%E5%89%AF%E4%BD%9C%E7%94%A8">清除副作用</a> (相应地 <code>onInvalidate</code> 会作为回调的第三个参数传入)、<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html#%E5%89%AF%E4%BD%9C%E7%94%A8%E5%88%B7%E6%96%B0%E6%97%B6%E6%9C%BA">副作用刷新时机</a>和<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html#%E4%BE%A6%E5%90%AC%E5%99%A8%E8%B0%83%E8%AF%95">侦听器调试</a>行为。</p>
<h3 id="与computed的区别"><a href="#与computed的区别" class="headerlink" title="与computed的区别"></a>与computed的区别</h3><p>对于Computed： </p>
<ul>
<li><p>它⽀持缓存，只有依赖的数据发⽣了变化，才会重新计算 </p>
</li>
<li><p>不⽀持异步，当Computed中有异步操作时，⽆法监听数据的变化 </p>
</li>
<li><p>computed的值会默认⾛缓存，计算属性是基于它们的响应式依赖进⾏缓存的，也就是基于data声 明过，或者⽗组件传递过来的props中的数据进⾏计算的。</p>
</li>
<li><p> 如果⼀个属性是由其他属性计算⽽来的，这个属性依赖其他的属性，⼀般会使⽤computed </p>
</li>
<li><p>如果computed属性的属性值是函数，那么默认使⽤get⽅法，函数的返回值就是属性的属性值；在 computed中，属性有⼀个get⽅法和⼀个set⽅法，当数据发⽣变化时，会调⽤set⽅法。</p>
</li>
</ul>
<p> 对于Watch： </p>
<ul>
<li>它不⽀持缓存，数据变化时，它就会触发相应的操作 </li>
<li>⽀持异步监听 监听的函数接收两个参数，第⼀个参数是最新的值，第⼆个是变化之前的值 </li>
<li>当⼀个属性发⽣变化时，就需要执⾏相应的操作 监听数据必须是data中声明的或者⽗组件传递过来的props中的数据，当发⽣变化时，会触发其他 操作，函数有两个的参数：<ul>
<li>immediate：副作用刷新时机 </li>
<li>deep：深度监听，发现数据内部的变化，在复杂数据类型中使⽤，例如数组中的对象发⽣变 化。需要注意的是，deep⽆法监听到数组和对象内部的变化。为了完全侦听深度嵌套的对象和数组，可能需要对值进行深拷贝。这可以通过诸如 <a target="_blank" rel="noopener" href="https://lodash.com/docs/4.17.15#cloneDeep">lodash.cloneDeep</a> 这样的实用工具来实现。</li>
</ul>
</li>
</ul>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2021/12/18/%E8%99%9A%E6%8B%9FDOM-%E8%BF%99%E6%AC%A1%E6%88%91%E5%8F%AF%E4%BC%9A%E8%AE%B2%E4%BA%86/" title="虚拟DOM 这次我可会讲了"><span class="has-text-weight-semibold">Next: 虚拟DOM 这次我可会讲了</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xiaoyangjia1/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/xiaoyangjia1"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Yangqixiang 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>