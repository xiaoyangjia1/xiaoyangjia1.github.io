<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>动态规划啊动态规划</title><meta name="description" content="yoloYang的个人博客网站"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/yqx.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
都说这种类型的题是最难的，我也有点惧怕，不过还是要迎难而上。
动态规划问题的一般形式就是求最值，求最值的核心就是穷举，暴力穷举会导致效率低下哎，所以我们需要一个备忘录来优化穷举过程。
而且，动态规划问题一定具备最优子结构，这样才能通过子问题的最值得到原问题的最值
动态规划三要素是重叠子问题（备忘录优化），最优子结构，状态转移方程，最难的一步就是构建出正确的状态转移方程。
动态规划采用自底向上的推理方法，从规模最小的一直推到规模最大的，所以动态规划一般都脱离了递归，采用循环迭代完成计算。
有了这些关于动态规划的了解后，我们来实战一下
凑零钱问题题目描述：给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回.."><meta name="generator" content="Hexo 5.4.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Yangqixiang's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">动态规划啊动态规划</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%91%E9%9B%B6%E9%92%B1%E9%97%AE%E9%A2%98"><span class="toc-text">凑零钱问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-text">题目分析：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E4%B8%89%E9%83%A8%E6%9B%B2"><span class="toc-text">状态转移方程三部曲</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E7%A1%AE%E5%AE%9A%E7%8A%B6%E6%80%81"><span class="toc-text">先确定状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9Adp%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-text">确定dp函数定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E9%80%89%E6%8B%A9%E5%B9%B6%E6%8B%A9%E4%BC%98"><span class="toc-text">确定选择并择优</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98"><span class="toc-text">消除重叠子问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0"><i class="tag post-item-tag">算法笔记</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">动态规划啊动态规划</h1><time class="has-text-grey" datetime="2021-12-09T11:54:04.000Z">2021-12-09</time><article class="mt-2 post-content"><p><img src="https://s2.loli.net/2021/12/09/ACbYJuRzwkFjrpo.jpg"></p>
<p>都说这种类型的题是最难的，我也有点惧怕，不过还是要迎难而上。</p>
<p>动态规划问题的一般形式就是求最值，求最值的核心就是穷举，暴力穷举会导致效率低下哎，所以我们需要一个备忘录来优化穷举过程。</p>
<p>而且，动态规划问题一定具备最优子结构，这样才能通过子问题的最值得到原问题的最值</p>
<p>动态规划三要素是重叠子问题（备忘录优化），最优子结构，状态转移方程，最难的一步就是构建出正确的状态转移方程。</p>
<p>动态规划采用自底向上的推理方法，从规模最小的一直推到规模最大的，所以动态规划一般都脱离了递归，采用循环迭代完成计算。</p>
<p>有了这些关于动态规划的了解后，我们来实战一下</p>
<h3 id="凑零钱问题"><a href="#凑零钱问题" class="headerlink" title="凑零钱问题"></a>凑零钱问题</h3><p>题目描述：给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">输入：coins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> amount <span class="token operator">=</span> <span class="token number">11</span>
输出：<span class="token number">3</span> 
解释：<span class="token number">11</span> <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">1</span></code></pre>

<p><strong>示例 2：</strong></p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">输入：coins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> amount <span class="token operator">=</span> <span class="token number">3</span>
输出：<span class="token operator">-</span><span class="token number">1</span></code></pre>

<p><strong>示例 3：</strong></p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">输入：coins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> amount <span class="token operator">=</span> <span class="token number">0</span>
输出：<span class="token number">0</span></code></pre>

<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><p>求最值问题，又有最优子结构，可以立马想到动态规划。</p>
<p>最优子结构即子问题间必须相互独立，在该题中，比如我想求amount=11时的最少硬币数，假设有数值为1的硬币，其实就是在求amount=10的最少硬币数+1。由于硬币的数量是没有限制的，子问题之间没有相互制约，所以是相互独立的。</p>
<p>我们既然知道该题是动态规划的题了，那么就得认真思考一下它的状态转移方程了。</p>
<h4 id="状态转移方程三部曲"><a href="#状态转移方程三部曲" class="headerlink" title="状态转移方程三部曲"></a>状态转移方程三部曲</h4><h5 id="先确定状态"><a href="#先确定状态" class="headerlink" title="先确定状态"></a>先确定状态</h5><p>状态即变量，在该题中唯一的状态是目标金额amount</p>
<h5 id="确定dp函数定义"><a href="#确定dp函数定义" class="headerlink" title="确定dp函数定义"></a>确定dp函数定义</h5><p>函数dp(n)表示，当前的目标金额n，至少需要dp(n)个硬币凑出该金额</p>
<h5 id="确定选择并择优"><a href="#确定选择并择优" class="headerlink" title="确定选择并择优"></a>确定选择并择优</h5><p>对于每个状态，可以做出什么选择改变当前状态。在该题中，无论当前目标金额是多少，选择就是从coins中选一个硬币，然后将目标金额减去选择的硬币值。</p>
<p>好的，现在我们可以得到状态转移方程了</p>
<p><img src="https://s2.loli.net/2021/12/09/UOYrI7PzvlgLhKN.jpg"></p>
<h4 id="消除重叠子问题"><a href="#消除重叠子问题" class="headerlink" title="消除重叠子问题"></a>消除重叠子问题</h4><p>我们使用自底向上的dp table来消除重叠子问题，dp数组的定义与dp函数的定义类似</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>初始化一个长度为amount+1，每个元素初始值为amount+1的dp数组，因为组成amount的最大硬币数为amount(即全都是1的硬币数组成)，初始化为amount+1相当于正无穷，便于后续取最小值</p>
<p>将第0位元素赋值为1，便于后续最小值比对</p>
<p>遍历dp数组，每次相当于计算目标金额为i的最小硬币数</p>
<p>每次遍历都要从coins中选择硬币做为dp[i-coin]（即最优子结构）进行最小值比对</p>
<p>在选择硬币前还要判断子结构是否存在，即i&lt;coin是无效的</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">coinChange</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">coins<span class="token punctuation">,</span> amount</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> dp <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> coin <span class="token keyword">of</span> coins<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> coin<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">continue</span>
            <span class="token punctuation">&#125;</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">==</span> amount<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2021/12/10/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/" title="vue3响应式原理"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: vue3响应式原理</span></a><a class="button is-default" href="/2021/12/09/dns/" title="浏览器输入URL到页面渲染数据这段时间内发生了啥事？聊聊域名系统"><span class="has-text-weight-semibold">Next: 浏览器输入URL到页面渲染数据这段时间内发生了啥事？聊聊域名系统</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="xiaoyangjia1/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/xiaoyangjia1"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Yangqixiang 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>